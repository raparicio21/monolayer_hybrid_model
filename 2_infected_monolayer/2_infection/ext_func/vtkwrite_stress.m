function vtkwrite_stress( filename,dataType,varargin )
% VTKWRITE Writes 3D Matlab array into VTK file format.
%  vtkwrite(filename,'structured_grid',x,y,z,'vectors',title,u,v,w) writes
%  a structured 3D vector data into VTK file, with name specified by the string
%  filename. (u,v,w) are the vector components at the points (x,y,z). x,y,z
%  should be 3-D matrices like those generated by meshgrid, where
%  point(ijk) is specified by x(i,j,k), y(i,j,k) and z(i,j,k).
%  The matrices x,y,z,u,v,w must all be the same size and contain
%  corrresponding position and vector component. The string title specifies
%  the name of the vector field to be saved. 
%
%  vtkwrite(filename,'structured_grid',x,y,z,'scalars',title,r) writes a 3D
%  scalar data into VTK file whose name is specified by the string
%  filename. r is the scalar value at the points (x,y,z). The matrices
%  x,y,z,r must all be the same size and contain the corresponding position
%  and scalar values. 
%
%  vtkwrite(filename,'structured_grid',x,y,z,'vectors',title,u,v,w,'scalars',
%  title2,r) writes a 3D structured grid that contains both vector and scalar values.
%  x,y,z,u,v,w,r must all be the same size and contain the corresponding
%  positon, vector and scalar values.
%
%  vtkwrite(filename, 'structured_points', title, m) saves matrix m (could
%  be 1D, 2D or 3D array) into vtk as structured points.
%
%  vtkwrite(filename, 'structured_points', title, m, 'spacing', sx, sy, sz)
%  allows user to specify spacing. (default: 1, 1, 1). This is the aspect
%  ratio of a single voxel. 
%
%  vtkwrite(filename, 'structured_points', title, m, 'origin', ox, oy, oz)
%  allows user to speicify origin of dataset. (default: 0, 0, 0).
%
%  vtkwrite(filename,'unstructured_grid',x,y,z,'vectors',title,u,v,w,'scalars',
%  title2,r) writes a 3D unstructured grid that contains both vector and scalar values.
%  x,y,z,u,v,w,r must all be the same size and contain the corresponding
%  positon, vector and scalar values.
%  
%  vtkwrite(filename, 'polydata', 'lines', x, y, z) exports a 3D line where
%  x,y,z are coordinates of the points that make the line. x, y, z are
%  vectors containing the coordinates of points of the line, where point(n)
%  is specified by x(n), y(n) and z(n).
%
%  vtkwrite(filename,'polydata','lines',x,y,z,'Precision',n) allows you to
%  specify precision of the exported number up to n digits after decimal
%  point. Default precision is 3 digits. 
%
%  vtkwrite(filename,'polydata','triangle',x,y,z,tri) exports a list of
%  triangles where x,y,z are the coordinates of the points and tri is an
%  m*3 matrix whose rows denote the points of the individual triangles.
%
%  vtkwrite(filename,'polydata','tetrahedron',x,y,z,tetra) exports a list
%  of tetrahedrons where x,y,z are the coordinates of the points
%  and tetra is an m*4 matrix whose rows denote the points of individual
%  tetrahedrons. 
%  
%  vtkwrite('execute','polydata','lines',x,y,z) will save data with default
%  filename ''matlab_export.vtk' and automatically loads data into
%  ParaView. 
%  
%  Version 2.3
%  Copyright, Chaoyuan Yeh, 2016
%  Codes are modified from William Thielicke and David Gingras's submission.    
if strcmpi(filename,'execute'), filename = 'matlab_export.vtk'; end
fid = fopen(filename, 'w'); 
% VTK files contain five major parts
% 1. VTK DataFile Version
fprintf(fid, '# vtk DataFile Version 2.0\n');



% 2. Title
fprintf(fid, 'Stresses\n');
binaryflag = any(strcmpi(varargin, 'BINARY'));
if any(strcmpi(varargin, 'PRECISION'))
    precision = num2str(varargin{find(strcmpi(varargin, 'PRECISION'))+1});
else
    precision = '2';
end
switch upper(dataType)       
    case {'STRUCTURED_GRID','POLYGONS'}




        % 3. The format data proper is saved in (ASCII or Binary). Use
        % fprintf to write data in the case of ASCII and fwrite for binary.
        if numel(varargin)<6, error('Not enough input arguments'); end
        setdataformat(fid, binaryflag);
%         fprintf(fid, 'BINARY\n');
        x = varargin{1};
        y = varargin{2};
        z = varargin{3};
        if sum(size(x)==size(y) & size(y)==size(z))~=length(size(x))
            error('Input dimesions do not match')
        end
        n_elements = numel(x);




        % 4. Type of Dataset ( can be STRUCTURED_POINTS, STRUCTURED_GRID,
        % UNSTRUCTURED_GRID, POLYDATA, RECTILINEAR_GRID or FIELD )
        % This part, dataset structure, begins with a line containing the
        % keyword 'DATASET' followed by a keyword describing the type of dataset.
        % Then the geomettry part describes geometry and topology of the dataset.
        if strcmpi(dataType,'STRUCTURED_GRID')
            fprintf(fid, 'DATASET STRUCTURED_GRID\n');
            fprintf(fid, 'DIMENSIONS %d %d %d\n', size(x,1), size(x,2), size(x,3));
        else
            fprintf(fid, 'DATASET POLYDATA \n'); % UNSTRUCTURED_GRID
        end
        fprintf(fid, ['POINTS ' num2str(n_elements) ' float\n']);
        output = [x(:)'; y(:)'; z(:)'];

%         for i = 1:n_elements
%             fprintf(fid, sprintf('%d %d %d\n',x(i),y(i),z(i)));
% 
%         end
%         tic
%         for i = 1:n_elements
%             spec = ['%0.', precision, 'f %0.', precision, 'f %0.', precision, 'f\n'];
%             fprintf(fid, spec, x(i), y(i), z(i));
%         end
%         toc

% This is 10 times faster and it is okay with Paraview format

        if ~binaryflag
            spec = ['%0.', precision, 'f\n'];
            fprintf(fid, spec, output);
        else
            fwrite(fid, output, 'float', 'b');
        end


        % Write connectivity
        num_vertices_per_element = size(varargin{4},2);
        numb_of_elements         = size(varargin{4},1);
        if num_vertices_per_element == 6
            total_data_number = numb_of_elements*(6+1);
        elseif num_vertices_per_element == 3
            total_data_number = numb_of_elements*(3+1);
        end

        fprintf(fid, sprintf('\nPOLYGONS %d %d\n',numb_of_elements, total_data_number));

        if num_vertices_per_element == 6
            fprintf(fid,'6 %d %d %d %d %d %d\n',(varargin{4}-1)');
        elseif num_vertices_per_element == 3
            fprintf(fid,'3 %d %d %d\n',(varargin{4}-1)');
        end
        




        % 5.This final part describe the dataset attributes and begins with the
        % keywords 'POINT_DATA' or 'CELL_DATA', followed by an integer number
        % specifying the number of points of cells. Other keyword/data combination
        % then define the actual dataset attribute values.
        fprintf(fid,sprintf('CELL_DATA %d\n',numb_of_elements));
        % Parse remaining argument.               
        iidx = find(strcmpi(varargin,'INT'    ));
        sidx = find(strcmpi(varargin,'SCALARS'));
        vidx = find(strcmpi(varargin,'VECTORS'));
        if iidx~=0
            for ii = 1:length(iidx)
                title = varargin{iidx(ii)+1};
                fprintf(fid, ['SCALARS ', title,' int\n']);
                fprintf(fid, 'LOOKUP_TABLE default\n');
                spec = '%d\n';
                fprintf(fid, spec, varargin{ iidx(ii) + 2});
%                 fwrite(fid, reshape(varargin{sidx(ii)+2},1,n_elements),'float','b');
            end
        end
        if sidx~=0
            for ii = 1:length(sidx)
                title = varargin{sidx(ii)+1};
                fprintf(fid, ['SCALARS ', title,' float\n']);
                fprintf(fid, 'LOOKUP_TABLE default\n');
                if ~binaryflag
                    spec = ['%0.', precision, 'f\n'];
                    fprintf(fid, spec, varargin{ sidx(ii) + 2});
                else
                    fwrite(fid, varargin{ sidx(ii) + 2}, 'float', 'b');
                end
%                 fwrite(fid, reshape(varargin{sidx(ii)+2},1,n_elements),'float','b');
            end
        end   
        if vidx~=0
            for ii = 1:length(vidx)
                title = varargin{vidx(ii)+1};
                % Data enteries begin with a keyword specifying data type
                % and numeric format.
                fprintf(fid, ['VECTORS ', title,' float\n']);
                output = [varargin{ vidx(ii) + 2 }(:,1)';...
                          varargin{ vidx(ii) + 2 }(:,2)';...
                          varargin{ vidx(ii) + 2 }(:,3)'];
                if ~binaryflag
                    if strcmp(title,'forces_x1e6') || strcmp(title,'cell_cell_interaction_forces') ...
                            || strcmp(title,'cell_cont_cent_forces')
                        spec = ['%0.', precision + 2, 'f\n'];
                        fprintf(fid, spec, output);
                    else
                        spec = ['%0.', precision, 'f\n'];
                        fprintf(fid, spec, output);
                    end   
                else
                    fwrite(fid, output, 'float', 'b');
                end
%                 fwrite(fid, [reshape(varargin{vidx(ii)+2},1,n_elements);...
%                 reshape(varargin{vidx(ii)+3},1,n_elements);...
%                 reshape(varargin{vidx(ii)+4},1,n_elements)],'float','b');
            end
        end                     
end
fclose(fid);
if strcmpi(filename,'matlab_export.vtk')
    switch computer
        case {'PCWIN','PCWIN64'}
            !paraview.exe --data='matlab_export.vtk' &
            % Exclamation point character is a shell escape, the rest of the
            % input line will be sent to operating system. It can not take
            % variables, though. The & at the end of line will return control to 
            % Matlab even when the outside process is still running. 
        case {'GLNXA64','MACI64'}
            !paraview --data='matlab_export.vtk' &
    end
end
end
function setdataformat(fid, binaryflag)
if ~binaryflag
    fprintf(fid, 'ASCII\n');
else
    fprintf(fid, 'BINARY\n');
end
end
